\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{geometry}

\title{Clock theory}
\author{bpaul}
\date{\today}

\newcommand{\ZZ}{\mathbb{Z}}

\begin{document}

\input{clockdisplay.tex}

\maketitle

WARNING:
I tried to write this document taking it seriously but lost motivation immediately!
Because of this, I have decided to take none of this seriously at all!
Hence this is going to be very unprofessional!!
Don't expect any of this to be well edited, expect lots of grammatical mistakes and poor wording, and perhaps completely false statements!
If you are an employer for some reason looking at all of my github repositories, do not look at the contents of this file, please!!!
If you have ever seen a document titled ``main.pdf" (I know lots of them are like that) about clock stuff written in late 2021, expect around the same quality (though maybe it won't be as bad).
Sorry!!

\section*{Introduction}

This is a render of a Rubik's clock.

\drawclock

It consists of 18 ``hands", 9 on each side, and 4 ``pins".
Each pin is ``up" on exactly one side, and down on the other side.
Dials on the top left, top right, bottom left and bottom right corners of the clock can be turned in order to rotate some of the hands.
Which hands are rotated depends on which pins are up or down.
Specifically, on the side that the pin adjacent to the dial turned is up, all hands touching a pin that is up will be rotated, and on the other side, only the ``corner" pieces will rotate.
Rotations occur in one twelfth increments.

For example, here is what occurs if we push the two left pins up, and turn the top left dial three times.

\setpins(1,0,1,0)
\move(3)

\drawclock

We can see that all six of the hands touching the pins on the front side rotate by three, and on the back side only the two corners that were touching the down pins rotate.
Note that the back face is reached by doing a ``y2 flip" (where we flip the clock along the vertical axis), which is why the pins on the back face may appear backwards.

This puzzle has many useful properties that makes its theory quite simple (relative to other Rubik's puzzles or other twisty puzzles).
The goal of this document is to explain this theory to a general audience, regardless of your background in mathematics.

\tableofcontents

\section{Modular arithmetic}

Modular arithmetic is when numbers wrap around after a point!
So when you work modulo 12 (in which case we call 12 the modulus), \(11 + 1 = 0\).
Just like on the clock!

There is a result from number theory (the division algorithm I think is what it is called) that states that every integer \(n\) can be written as
\[
    n = pq + r \qquad 0 \leq r < q.
\]
For example if \(n = -5\) and \(q = 12\) then \(n = -1 * 12 + 7\).
In particular, when \(q\) is the modulus we are working over, any integer \(n\) can be ``converted" into an integer between \(0\) and \(q\) excluding \(q\) that preserves its value module \(q\).
Lets call this number, \(\mathbf{m}(n)\).
We can then define the modular integers \(\ZZ_m\) as the set
\[
    \ZZ_m = \{n \mid 0 \leq n < m\}
\]
and define addition on \(\ZZ_m\) by
\[
    a +_{\ZZ_m} b = m(a + b)
\]
where we use regular integer addition before taking the correct number modulo \(m\).
We can define multiplication similarly!
\[
    a *_{\ZZ_m} b = m(ab)
\]
From this point onwards, when we state that \(a\) and \(b\) are elements of \(\ZZ_m\) and write \(a + b\), we mean \(a +_{\ZZ_m} b\), and similarly we write \(ab\) to mean \(a *_{\ZZ_m} b\).

The modular integers form what is called a ring.
If you want to learn about proper maths I recommend reading an abstract algebra textbook that covers rings and seeing how the modular integers are constructed over there (they hopefully do a quotient ring by the ideal generated by \(m\)).
We use this kinda crude construction because it's hopefully understandable!
Importantly however, because of obviousness, \(a + b = b + a\)!!!
This is very important!!!
Also, \(ab = ba\)!!
Anyways lets define this new thing called a unit.

A number \(x \in \ZZ_m\) is a unit if there is another number \(y \in \ZZ_m\) such that \(x y = 1\).
You should think of \(y\) as \(x^{-1}\), or like one divided by \(x\) kinda!!
Obviously we don't have fractions in \(\ZZ_m\), so how could any number be a unit?!
Well, \(1\) is always a unit, since we can choose \(y = 1\).
Similarly, \(m - 1\) is always a unit, since \((m - 1)^2 = m^2 - 2m + 1 = 1 \pmod{m}\).
In fact, there is a result that tells us precisely when a number modulo \(m\) is a unit, coming from the so called extended Euclidian algorithm!
The statement is that for fixed \(c, d, e \in \ZZ\), the equation \(ac + bd = e\) has integer solutions to \(a\) and \(b\) if and only if \(e\) is a multiple of \(\gcd(c, d)\).
In particular, if we set \(d = m, e = 1\), then
\[
    ac + bm = 1
\]
has a solution if and only if \(\gcd(c, m) = 1\).
This equation is equivalent to \(ac \equiv 1 \pmod{m}\), and so \(c\) is a unit if and only if \(\gcd(c, m) = 1\).
That's pretty cool!
But why should anyone care?
Well, it turns out that units are pretty important clock theory.

When we're working with the clock, we are concerned with the case of \(m = 12\).
In this case, the units of \(Z_12\) are \(1, 5, 7, 11\), and you should verify this!

% Operations (addition, multiplication)
% note commutativity!

% Units (gcds and euclid's algorithms included?)



% Clock represented as a Z12 module and linear algebra for free Z12 modules

% Represent a clock state as a vector

% Moves as a 30x14 matrix

% Pin sets as choices of subsets of the spanning set

% Echelon forms??



% 7 Simul

%



% Parity



% pseudo

\end{document}
